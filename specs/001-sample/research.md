# Research: Personal Blog Publishing Flow

## 1. Rich Text + MDX Editing Experience
- **Decision**: Use TipTap 2 (ProseMirror) with a custom extension set plus MDX sync powered by Contentlayer.
- **Rationale**: TipTap offers first-class React bindings, allows us to enforce the exact formatting controls (headings, bold/italic, code blocks, image/video embeds), and can serialize to JSON + Markdown so we can store drafts consistently. Contentlayer handles `.md/.mdx` parsing with remark/rehype, letting us share validation logic between imports and the in-browser editor.
- **Alternatives considered**: Slate.js (lighter but weaker embed support); Lexical (fast but MDX serialization immature); building a bespoke Markdown editor (high effort, little reuse).

## 2. Draft Storage & Encryption
- **Decision**: Store draft blobs (editor JSON + MDX source) in a private AWS S3 bucket with SSE-S3 encryption and block public ACLs. Metadata (status, schedule, appearance settings) lives in Supabase Postgres with row-level security keyed to author_id. Access is via signed URLs generated by Next.js route handlers.
- **Rationale**: S3 offers durable object storage, simple size quotas (8 MB enforcement), lifecycle policies, and integrates with CloudFront for eventual CDN needs. Supabase Postgres provides managed auth-friendly row policies so drafts remain author-only while keeping scheduling queries efficient.
- **Alternatives considered**: Firebase Storage (simpler SDK but weaker server-side encryption controls); storing drafts directly in Postgres bytea columns (expensive for large MDX + media); local browser storage (violates requirement for online drafts).

## 3. Tag Suggestion Engine
- **Decision**: Generate tag suggestions via an AWS Lambda that runs OpenSearch Keyword Extraction (k-NN) on the article body, returning top 5 proper nouns / key phrases, then allow the client to edit/remove them before saving.
- **Rationale**: Fully managed service, deterministic performance, and keeps PII on our infra. Lambda invocation keeps latency under 400 ms for typical articles and scales with demand without dedicated servers.
- **Alternatives considered**: OpenAI API (great quality but external data residency + cost concerns); TF-IDF in browser (fast but low accuracy for mixed languages); bespoke NLP service (high maintenance).

## 4. Scheduling & JST Enforcement
- **Decision**: Use BullMQ + Upstash Redis to enqueue publish jobs with timestamps stored in Supabase (TIMESTAMP WITH TIME ZONE). A dedicated `services/publisher` worker running on AWS Lambda (via Serverless) polls due jobs every minute in JST (converted to UTC under the hood) and executes publish logic (status change + cache purge). Editing a scheduled post triggers an interstitial modal prompting reschedule; the worker logs user responses.
- **Rationale**: BullMQ natively supports delayed jobs with Redis; Upstash offers managed Redis in ap-northeast-1, aligning with JST. Lambda scheduler keeps ops simple and ensures at-least-once execution, while Supabase acts as single source of truth for schedule auditing.
- **Alternatives considered**: Cron-based scheduler (harder to manage dynamic jobs); Temporal.io (powerful but overkill for current scale); Cloud Tasks (adds GCP dependency).

## 5. Performance & Cache Strategy
- **Decision**: Serve the top page as a statically generated Next.js route with ISR (revalidate=30s) plus client-side hydration, backed by an Edge-compatible KV cache for category pagination snapshots. Use AWS CloudFront (via Vercel CDN) for global distribution and instrument `frontend.first_paint_ms` with Web Vitals reports. Publish/unpublish actions trigger webhooks that invalidate relevant paths and flush CDN cache to hit the <1 s first paint & <60 s unpublish SLA.
- **Rationale**: ISR keeps latency low without rebuilding the entire site, caches reduce database hits, and Web Vitals capture ensures we continuously validate SC-001/SC-004. Cache purge hooks satisfy requirement to update header/category listings quickly after toggling publish state.
- **Alternatives considered**: Fully dynamic SSR (simpler but slower under load); pure static export (can’t honor scheduling/drafts); client-side fetching only (risks >1 s first paint).

## 6. File Size Warning UX (FR-011)
- **Decision**: Display an inline toast + file list callout: “Upload blocked: `<filename>` is 12 MB. Markdown/MDX files and referenced media must be 8 MB or smaller. See docs/blog/import-limits.” Provide a link to the docs article and keep severity at “error”.
- **Rationale**: Keeps guidance contextual, clarifies whether the violation comes from the manuscript or embedded media, and offers self-serve remediation without blocking other work.
- **Alternatives considered**: Modal dialog (too disruptive); silent form validation (users miss reason); server-only error (slower feedback).

## 7. Failure Email Template (FR-012)
- **Decision**: Send via AWS SES from `notify@blog.example.com` with subject “Publish failed for <article title>”. Body includes failure reason, last attempted schedule time, CTA button linking back to the editor with `?articleId=...&reschedule=true`, and a note that another attempt will run once the user confirms.
- **Rationale**: Clear sender identity improves deliverability, consistent copy speeds debugging, and the deep link reduces recovery time.
- **Alternatives considered**: In-app notifications only (violates requirement); SMS (extra infra); sending from default AWS address (hurts trust/deliverability).
